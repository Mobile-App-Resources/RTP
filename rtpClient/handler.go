package rtpClient

import (
	"fmt"
	"github.com/antongulenko/gortp"
)

var CtrlEvents = map[int]string{
	rtp.NewStreamData:             "new stream (data)",               // Input stream creation triggered by a RTP data packet
	rtp.NewStreamCtrl:             "new stream (ctrl)",               // Input stream creation triggered by a RTCP control packet
	rtp.MaxNumInStreamReachedData: "max number of streams (data)",    // Maximum number of input streams reached while receiving an RTP packet
	rtp.MaxNumInStreamReachedCtrl: "max number of streams (ctrl)",    // Maximum number of input streams reached while receiving an RTCP packet
	rtp.WrongStreamStatusData:     "wrong stream status (data)",      // Received RTP packet for an inactive stream
	rtp.WrongStreamStatusCtrl:     "wrong stream status (ctrl)",      // Received RTCP packet for an inactive stream
	rtp.StreamCollisionLoopData:   "stream collision or loop (data)", // Detected a collision or loop processing an RTP packet
	rtp.StreamCollisionLoopCtrl:   "stream collision or loop (ctrl)", // Detected a collision or loop processing an RTCP packet

	// Actual RTCP status codes
	rtp.RtcpSR:    "sender report",
	rtp.RtcpRR:    "receiver report",
	rtp.RtcpSdes:  "source description",
	rtp.RtcpBye:   "goodbye",
	rtp.RtcpApp:   "application defined",
	rtp.RtcpRtpfb: "generic RTP feedback",
	rtp.RtcpPsfb:  "payload specific",
	rtp.RtcpXr:    "extended report",
}

func CtrlEventString(event *rtp.CtrlEvent) string {
	var eventName string
	var ok bool
	if eventName, ok = CtrlEvents[event.EventType]; !ok {
		eventName = "unknown"
	}
	reason := event.Reason
	if reason != "" {
		reason = " (reason: " + reason + ")"
	} else if event.EventType < 100 {
		// Artificial event generated by gortp
		reason = fmt.Sprintf(" (ssrc: %v)", event.Ssrc)
	}
	return fmt.Sprintf("Ctrl (%v, %s)%s", event.EventType, eventName, reason)
}

func (client *RtpClient) handleCtrlEvents() {
	defer client.wg.Done()
	for signals := range client.ctrlChan {
		for _, signal := range signals {
			client.CtrlStats.AddPacketNow()
			if client.CtrlHandler != nil {
				client.CtrlHandler(signal)
			}
		}
	}
}

func (client *RtpClient) handleDataPackets() {
	defer client.wg.Done()
	for data := range client.dataChan {
		client.ReceiveStats.AddNow(uint(data.InUse()))
		seq := data.Sequence()
		cur := client.sequenceNumber
		if cur != 0 && cur+1 != seq {
			client.MissedStats.AddPacketsNow(uint(seq - cur - 1))
		}
		client.sequenceNumber = seq
		if client.DataHandler != nil {
			client.DataHandler(data)
		}
	}
}
