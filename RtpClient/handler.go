package rtpClient

import (
	"fmt"
	"github.com/antongulenko/gortp"
	"time"
)

var CtrlEvents = map[int]string{
	rtp.NewStreamData:             "new stream (data)",               // Input stream creation triggered by a RTP data packet
	rtp.NewStreamCtrl:             "new stream (ctrl)",               // Input stream creation triggered by a RTCP control packet
	rtp.MaxNumInStreamReachedData: "max number of streams (data)",    // Maximum number of input streams reached while receiving an RTP packet
	rtp.MaxNumInStreamReachedCtrl: "max number of streams (ctrl)",    // Maximum number of input streams reached while receiving an RTCP packet
	rtp.WrongStreamStatusData:     "wrong stream status (data)",      // Received RTP packet for an inactive stream
	rtp.WrongStreamStatusCtrl:     "wrong stream status (ctrl)",      // Received RTCP packet for an inactive stream
	rtp.StreamCollisionLoopData:   "stream collision or loop (data)", // Detected a collision or loop processing an RTP packet
	rtp.StreamCollisionLoopCtrl:   "stream collision or loop (ctrl)", // Detected a collision or loop processing an RTCP packet

	// Actual RTCP status codes
	rtp.RtcpSR:    "sender report",
	rtp.RtcpRR:    "receiver report",
	rtp.RtcpSdes:  "source description",
	rtp.RtcpBye:   "goodbye",
	rtp.RtcpApp:   "application defined",
	rtp.RtcpRtpfb: "generic RTP feedback",
	rtp.RtcpPsfb:  "payload specific",
	rtp.RtcpXr:    "extended report",
}

func (client *RtpClient) handleCtrlEvents() {
	defer client.wg.Done()
	for signals := range client.ctrlChan {
		for _, signal := range signals {
			client.handleCtl(signal)
		}
	}
}

func (client *RtpClient) handleDataPackets() {
	defer client.wg.Done()
	for data := range client.dataChan {
		client.handleData(data)
	}
}

func (client *RtpClient) handleCtl(event *rtp.CtrlEvent) {
	var eventName string
	var ok bool
	if eventName, ok = CtrlEvents[event.EventType]; !ok {
		eventName = "unknown"
	}
	reason := event.Reason
	if reason != "" {
		reason = " (reason: " + reason + ")"
	} else if event.EventType < 100 {
		// Artificial event generated by gortp
		reason = fmt.Sprintf(" (ssrc: %v)", event.Ssrc)
	}
	fmt.Printf("Ctrl (%v, %s)%s\n", event.EventType, eventName, reason)
}

func (client *RtpClient) handleData(data *rtp.DataPacket) {
	now := time.Now()
	// TODO evaluate length: data.InUse()
	seq := data.Sequence()
	if client.missed != 0 && client.sequence+1 != seq {
		missed := uint(seq - client.sequence - 1)
		client.missed += missed
		fmt.Printf("Missed %v packets (total %v)\n", missed, client.missed)
	}
	client.sequence = seq
	client.ReceiveStats.Packets <- now
}
